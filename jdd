#!/usr/bin/env bash

# jdd is a diff-over-time navigator for JSON objects.
#
# dive: stream or store successive versions of a JSON object as a JSONL file, and use jdd to dive through the changes.
# surf: explore a single JSON object via interactive query preview.

# dive is the main jdd command.
#
# Usage: jdd [dive] [FILE] [OPTIONS]
function dive {
    # Save stdin for later use
    exec 3<&0
    exec </dev/null

    local -a files=()
    local do_record=false
    local watch=""
    local interval=5
    local save_file=""
    local force_save_file=false
    local tag=""
    local do_preprocess=false
    local do_uniq=true
    local do_follow=false
    local no_follow=false
    local do_show_info=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --record|--rec|-r) do_record=true ; shift ;;
            --watch|-w) watch="$2" ; shift 2 ;;
            --interval|--int|-i) interval="$2" ; shift 2 ;;
            --file) save_file="$2" ; shift 2 ;;
            --force) force_save_file=true ; shift ;;
            --tag) tag="$2" ; shift 2 ;;
            --preprocess|--pre) do_preprocess=true ; shift ;;
            --all) do_uniq=false ; shift ;;
            --follow|-f) do_follow=true ; shift ;;
            --no-follow) no_follow=true ; shift ;;
            --info) do_show_info=true ; shift ;;
            --help|-h) help ; return 0 ;;
            -*) err "Unknown option: $1" ; help ; return 1 ;;
            *) files+=("$1") ; shift ;;
        esac
    done

    local has_file=false
    local multi_file=false
    [[ ${#files[@]} -gt 0 ]] && has_file=true
    [[ ${#files[@]} -gt 1 ]] && multi_file=true

    [[ "$do_follow" = true && "$no_follow" = true ]] && { err "Cannot specify both --follow and --no-follow" ; return 1 ; }
    [[ "$has_file" = true && -n "$watch" ]] && { err "Cannot specify both FILE and --watch" ; return 1 ; }
    [[ -n "$watch" && "$no_follow" = true ]] && { err "Cannot specify both --watch and --no-follow" ; return 1 ; }
    [[ "$do_record" = true && "$has_file" = false ]] && { err "--record requires a FILE argument" ; return 1 ; }
    [[ "$do_record" = true && "$no_follow" = true ]] && { err "--record cannot be used with --no-follow" ; return 1 ; }
    [[ "$do_record" = true && -n "$watch" ]] && { err "Cannot specify both --record and --watch" ; return 1 ; }

    [[ -n "$watch" || ( "$has_file" = false && "$no_follow" = false ) ]] && do_follow=true

    for file in "${files[@]}"; do
        [[ ! -f "$file" ]] && { err "File does not exist: $file" ; return 1 ; }
        [[ ! -r "$file" ]] && { err "File is not readable: $file" ; return 1 ; }
        [[ ! -s "$file" ]] && { err "File is empty: $file" ; return 1 ; }
    done
    if [[ -n "$save_file" && -e "$save_file" ]] ; then
        [[ ! -f "$save_file" ]] && { err "--file '$save_file' is not a regular file." ; return 1 ; }
        [[ ! -w "$save_file" ]] && { err "--file '$save_file' is not writable." ; return 1 ; }
        if [[ "$force_save_file" = true ]] ; then
            rm -f "$save_file"
            debug "Removed existing save_file: '$save_file'"
        else
            err "--file '$save_file' already exists. Use --force to overwrite."
            return 1
        fi
    fi

    local val_idx=2
    local jq_prog='[input_line_number, . ] | @tsv'
    if [[ -n "$tag" ]] ; then
        jq_prog="(try (fromjson | $tag) catch null) as \$h | [input_line_number, (\$h // \"\"), .] | @tsv"
        val_idx=3
    fi

    local -a preprocessor=(jq --unbuffered --sort-keys --compact-output .)
    [[ -n "$JDD_PREPROCESSOR" ]] && eval "preprocessor=($JDD_PREPROCESSOR)"
    local -a watcher=(true)
    [[ -n "$watch" ]] && eval "watcher=($watch)"

    local previewer="${JDD_PREVIEWER:-jq --color-output .}"
    local differ="${JDD_DIFFER:-jsondiffpatch}"
    local inspector="${JDD_INSPECTOR:-fx}"
    local copier="${JDD_COPIER:-pbcopy}"

    function maybe_preprocess { if [[ "$do_preprocess" = true ]] ; then "${preprocessor[@]}" ; else cat ; fi ; }
    function maybe_tail { if [[ "$do_follow" = true ]] ; then tail -n +1 -f "$1" ; else cat "$1" ; fi ; }
    function maybe_uniq { if [[ "$do_uniq" = true ]] ; then awk 'NR==1 { print $0; last=$0; fflush(); next } { if ($0 != last) { print $0; last=$0; fflush() } }' ; else cat ; fi ; }
    function maybe_uniq_watch {
        if [[ "$do_uniq" = true ]]; then
            local last ; last=$(sed -n '$p' "$1" 2>/dev/null || true)
            while IFS= read -r line; do
                if ! "${differ[@]}" <(printf "%s" "$last") <(printf "%s" "$line") >/dev/null 2>&1 ; then
                    printf "%s\n" "$line"
                    last="$line"
                fi
            done
        else
            cat
        fi
    }

    debug "Inputs"
    debug "  files: ${files[*]}"
    debug "  do_record: $do_record"
    debug "  watch: $watch"
    debug "  interval: $interval"
    debug "  save_file: $save_file"
    debug "  tag: $tag"
    debug "  do_preprocess: $do_preprocess"
    debug "  do_uniq: $do_uniq"
    debug "  do_follow: $do_follow"
    debug "  no_follow: $no_follow"
    debug "  do_show_info: $do_show_info"
    debug "Intermediates"
    debug "  json_prog: $jq_prog"
    debug "Actors"
    debug "  preprocessor: ${preprocessor[*]}"
    debug "  watcher: ${watcher[*]}"
    debug "  previewer: $previewer"
    debug "  differ: $differ"
    debug "  inspector: $inspector"
    debug "  copier: $copier"

    # Need a tmp file if we're multi-files, recording, watching, altering the file, or reading from stdin
    inp_file="${files[0]}"
    if [[ "$multi_file" = true ]] ; then
        file=$(get_save_file "$save_file") || return 1
        debug "Combine multiple input files ${files[*]} into file: $file"
        cat "${files[@]}" | maybe_preprocess | maybe_uniq >> "$file"
    elif [[ "$do_record" = true ]] ; then
        # Recording
        file=$(get_save_file "$save_file") || return 1
        do_follow=true  # implies follow
        debug "Record changes to input file '$inp_file' into file: $file"
        (
            cat "$inp_file" | maybe_preprocess >> "$file"
            fswatch --one-per-batch --print0 --follow-links "$inp_file" | while read -r -d "" _ ; do cat "$inp_file" | maybe_preprocess | maybe_uniq_watch "$file" | sponge >> "$file" ; done
        ) & pid_inp=$!
    elif [[ -n "$watch" ]] ; then
        # Watch
        file=$(get_save_file "$save_file") || return 1
        do_follow=true  # implies follow
        debug "Watch command '${watcher[*]}' into file: $file"
        ( while true ; do "${watcher[@]}" | maybe_preprocess | maybe_uniq_watch "$file" | sponge >> "$file" ; sleep "$interval" ; done ) & pid_inp=$!
    elif [[ -n "$inp_file" && ("$do_uniq" = true || "$do_preprocess" = true) ]] ; then
        # Altered file
        file=$(get_save_file "$save_file") || return 1
        debug "Process input file '$inp_file' into file: $file"
        if [[ "$do_follow" = true ]] ; then
            ( tail -n +1 -f "$inp_file" | maybe_preprocess | maybe_uniq >> "$file" ) & pid_inp=$!
        else
             cat "$inp_file" | maybe_preprocess | maybe_uniq >> "$file"  # this is the only sync case in this block
        fi
    elif [[ -z "$inp_file" ]] ; then
        # Stdin
        file=$(get_save_file "$save_file") || return 1
        debug "Read stdin into file: $file"
        if [[ "$do_follow" = true ]] ; then
            ( cat <&3 | maybe_preprocess | maybe_uniq >> "$file" ) & pid_inp=$!
        else
             cat <&3 | maybe_preprocess | maybe_uniq >> "$file"
        fi
    else
        # Unaltered file
        debug "Use input file as-is: $inp_file"
    fi
    [[ -n "$pid_inp" ]] && spawned_pids+=("$pid_inp") && debug "Spawned pid_inp: $pid_inp"
    exec 3<&-

    # Emit lines into a fifo for fzf to read from
    # Use a fifo to ease subprocess cleanup
    function emit_lines { maybe_tail "$file" | jq --unbuffered --raw-input --raw-output "$jq_prog" ; }
    fifo_dir=$(mktemp -d)
    fifo="$fifo_dir/fifo" ; mkfifo "$fifo"
    ( emit_lines > "$fifo" ) & pid_emit=$!
    [[ -n "$pid_emit" ]] && spawned_pids+=("$pid_emit") && debug "Spawned pid_emit: $pid_emit"

    local -a headers=()
    [[ -z "$JDD_NO_HELP" ]] && headers+=("Ctrl-/ for help")
    [[ "$do_show_info" = true || -n "$JDD_SHOW_FILE" || -n "$JDD_DEBUG" ]] && headers+=("File: $file")
    local -a header=()
    if (( ${#headers[@]} )); then
        joined=""
        for h in "${headers[@]}"; do
            [[ -n "$joined" ]] && joined+=" | "
            joined+="$h"
        done
        header+=(--header "$joined")
    fi

    # Print waiting message if no input after a while
    local max_wait=3000  # milliseconds
    local waited=0
    local printed=false
    while [[ ! -s "$file" ]]; do
        kill -0 "$pid_inp" 2>/dev/null || { err "No JSON received." ; return 1 ; }
        sleep 0.1
        waited=$((waited + 100))
        if [[ $waited -ge "$max_wait" && "$printed" = false ]]; then
            printf "Waiting for input..." >&2
            printed=true
        fi
    done

    FILE="$file" PREVIEWER="$previewer" DIFFER="$differ" INSPECTOR="$inspector" COPIER="$copier" \
        fzf < "$fifo" \
            --exact \
            --delimiter=$'\t' \
            --accept-nth="${val_idx}.." \
            --track \
            --no-sort \
            "${header[@]}" \
            --info=inline-right \
            --tabstop=4 \
            --freeze-left=2 \
            --layout=reverse \
            --tiebreak=begin,chunk,length \
            --with-shell="bash -lc" \
            --preview-window="bottom:70%,wrap" \
            --bind "ctrl-n:down" \
            --bind "ctrl-p:up" \
            --bind "ctrl-j:page-down" \
            --bind "ctrl-d:page-down" \
            --bind "ctrl-k:page-up" \
            --bind "ctrl-u:page-up" \
            --bind "ctrl-h:preview-page-up" \
            --bind "ctrl-l:preview-page-down" \
            --bind "ctrl-f:first" \
            --bind "ctrl-g:last" \
            --bind "ctrl-v:up-match" \
            --bind "ctrl-b:down-match" \
            --bind "ctrl-t:best" \
            --bind "ctrl-w:clear-query" \
            --bind "ctrl-r:toggle-raw" \
            --bind 'ctrl-/:execute:jdd help --keys | ${PAGER:-less -R}' \
            --bind 'ctrl-y:execute-silent:
                idx={1}
                $COPIER <(sed -n "${idx}p" "$FILE")
            ' \
            --bind "ctrl-o:accept" \
            --bind 'enter:transform:
                q={q}
                idx={1}
                if [[ ! $FZF_PROMPT =~ ^goto ]]; then
                    echo "execute($INSPECTOR <(sed -n "${idx}p" "$FILE"))"
                    exit 0
                fi
                if [[ "$q" =~ ^[0-9]+$ ]]; then
                    echo "enable-search+pos($q)+change-prompt(> )+clear-query"
                    exit 0
                fi
                echo "enable-search+change-prompt(> )+clear-query"
            ' \
            --bind 'tab:transform:
                q={q}
                if [[ ! $FZF_PROMPT =~ ^goto ]]; then
                    echo "disable-search+change-prompt(goto> )+clear-query"
                    exit 0
                fi
                if [[ "$q" =~ ^[0-9]+$ ]]; then
                    echo "enable-search+pos($q)+change-prompt(> )+clear-query"
                    exit 0
                fi
                echo "enable-search+change-prompt(> )+clear-query"
            ' \
            --bind 'esc:transform:
                if [[ ! $FZF_PROMPT =~ ^goto ]]; then
                    echo "abort"
                    exit 0
                fi
                echo "enable-search+change-prompt(> )+clear-query"
            ' \
            --preview '
                idx={1}
                if [ "$idx" -eq 1 ]; then
                    sed -n "${idx}p" "$FILE" | $PREVIEWER
                else
                    prev=$((idx - 1))
                    FORCE_COLOR=1 $DIFFER <(sed -n "${prev}p" "$FILE") <(sed -n "${idx}p" "$FILE")
                fi
            '
}

# surf explores a single JSON object via interactive query preview.
#
# Usage: jdd surf [FILE] [OPTIONS]
function surf {
    local -a files=()
    local save_file=""
    local do_show_info=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --info) do_show_info=true ; shift ;;
            --help|-h) help ; return 0 ;;
            -*) err "Unknown option: $1" ; help ; return 1 ;;
            *) files+=("$1") ; shift ;;
        esac
    done

    [[ ${#files[@]} -gt 1 ]] && { err "surf only supports a single FILE" ; return 1 ; }

    file="${files[0]}"
    [[ -z "$file" ]] && { file=$(get_save_file "$save_file" "json") && cat > "$file" || return 1 ; }
    [[ ! -f "$file" ]] && { err "File does not exist: $file" ; return 1 ; }
    [[ ! -r "$file" ]] && { err "File is not readable: $file" ; return 1 ; }
    [[ ! -s "$file" ]] && { err "File is empty: $file" ; return 1 ; }

    surfer="${JDD_SURFER:-jaq}"
    surfer_preview="${JDD_SURFER_PREVIEW:-${surfer} --color-output}"
    surfer_output="${JDD_SURFER_OUTPUT:-${surfer} --raw-output}"

    local -a header=()
    [[ "$do_show_info" = true || -n "$JDD_SHOW_FILE" ]] && header+=(--header "File: $file")

    FILE="$file" PREVIEW="$surfer_preview" OUTPUT="$surfer_output" fzf < /dev/null \
        --disabled \
        --print-query \
        --ghost="." \
        "${header[@]}" \
        --prompt="jq> " \
        --no-info \
        --layout=reverse \
        --with-shell="bash -lc" \
        --preview-window="bottom:99%" \
        --bind 'ctrl-o:become:$OUTPUT {q} $FILE 2>/dev/null || $OUTPUT . $FILE || echo "Could not evaluate query." >&2' \
        --preview='$PREVIEW {q} $FILE 2>/dev/null || $PREVIEW . $FILE || echo "Could not evaluate query." >&2'
}

function help {
    local dive_keybindings=(
        "Ctrl-/|Help (this message -- q to quit)"
        "Ctrl-N/Down|Down"
        "Ctrl-P/Up|Up"
        "Ctrl-J/Ctrl-D|Page down"
        "Ctrl-K/Ctrl-U|Page up"
        "Ctrl-L|Preview page down"
        "Ctrl-H|Preview page up"
        "Ctrl-F|Jump to first entry"
        "Ctrl-G|Jump to last entry"
        "Ctrl-V|Jump to previous match"
        "Ctrl-B|Jump to next match"
        "Ctrl-T|Jump to best match"
        "Ctrl-R|Toggle raw view"
        "Ctrl-W|Clear query"
        "Ctrl-Y|Copy current JSON entry to clipboard"
        "Ctrl-O|Output current JSON entry to stdout and exit"
        "Tab|Toggle 'goto' mode for jump to line number"
        "Enter|Open in fx for further inspection"
    )

    local just_keybindings=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keys) just_keybindings=true ; shift ;;
            *) debug "Unknown option: $1" ; shift ;;
        esac
    done

    [[ "$just_keybindings" = false ]] && cat >&2 <<EOF
Navigate successive versions of a JSON object.

Usage: jdd [COMMAND] [FILE...] [OPTIONS]

Args:
    COMMAND             The jdd command to run (dive, surf). If omitted, guessed from FILE extension and options.
    FILE                Input file(s). If omitted, reads from stdin. If multiple files, treat as successive versions.

Commands:
    (no command)        Guess command from FILE extension
    dive|hist           Navigate successive versions of a JSON object, via streaming or stored JSONL file.
    surf|insp           Explore a single JSON object via interactive query preview.
    help                Show this help message.

Options:
    --info              Show more info, like the file being processed.

Dive options:
    --record COMMAND    FILE Record mode: monitor FILE for changes and append new JSON object versions to it. (Alias: --rec, -r)
    --watch COMMAND     Watch mode: run COMMAND periodically to get new JSON object versions. (Alias: -w)
    --interval N        Interval in seconds between watch COMMAND executions (default: 5). (Alias: --int, -i)
    --file SAVE_FILE    Specify SAVE_FILE to store observed/intermediate changes (default: temporary file; recommendation: .jsonl extension).
    --preprocess        Preprocess each JSON entry into a single line before further processing (configure via JDD_PREPROCESSOR). (Alias: --pre)
    --follow            Follow mode: keep reading new entries as they are appended to FILE (default if no FILE is given). (Alias: -f)
    --no-follow         Disable follow mode.
    --all               Do not filter out consecutive duplicate entries (if using FILE, also prevents creating an intermediate file).
    --tag OBJECT_PATH   Specify JSON object path to use as tag for each entry.

Dive keybindings:
EOF

    for kb in "${dive_keybindings[@]}"; do
        key="${kb%%|*}"
        desc="${kb#*|}"
        if [[ "$just_keybindings" = true ]]; then
            pfield 19 "$key" "$desc"
        else
            pfield 23 "    $key" "$desc." >&2
        fi
    done
}


# get_save_file returns the save file path, creating a temporary file if needed.
#
# Usage: get_save_file SAVE_FILE [TMP_EXTENSION]
function get_save_file {
    local save_file="$1"
    local tmp_extension="${2:-jsonl}"
    if [[ -n "$save_file" ]] ; then
        printf "%s" "$save_file"
    else
        local tmp out
        tmp=$(mktemp -t "jdd") || { err "Failed to create temporary file for save_file" ; return 1 ; }
        out="$tmp.$tmp_extension"
        mv "$tmp" "$out" || { err "Failed to move temporary file to final save_file: '$tmp' to '$out'" ; return 1 ; }
        printf "%s" "$out"
    fi
}

# sponge collects all of stdin before writing to stdout.
function sponge {
    tmpfile=$(mktemp)
    cat > "$tmpfile"
    [[ -s "$tmpfile" ]] && cat "$tmpfile"
    rm -f "$tmpfile"
}


function err { echo "$@" >&2 ; }  # error print to stderr
function debug { [[ -n "$JDD_DEBUG" ]] && echo "[DEBUG] $*" >&2 ; }  # debug print, only if JDD_DEBUG is set
function pfield { printf "%-*s %s\n" "$1" "$2" "$3" ; }  # print one row of a two-column table


# cleanup recursively kills child processes of the given PID.
#
# Requires: kill, pgrep
#
# REF: https://stackoverflow.com/questions/2618403
#
# Usage: cleanup PID [AND_SELF] [DEPTH]
function cleanup_all {
    local pid="$1"
    local and_self="${2:-false}"
    local depth="${3:-0}" ; local indent="" ; for ((i=0; i<depth; i++)) ; do indent+="  " ; done
    if children=$(pgrep -P "$pid" 2>/dev/null); then
        c=$(printf '%s' "$children" | tr '\n' ' ')
        debug "${indent}Killing desc of pid $1: [$c]..."
        for child in $children; do
            cleanup_all "$child" true $((depth + 1))
        done
    fi
    if [[ "$and_self" == true ]]; then
        debug "${indent}Kill $pid"
        kill -- "$pid" > /dev/null 2>&1 || true
    fi
}

# cleanup kills all tracked spawned child processes.
#
# Requires: kill [DEPTH]
function cleanup_tracked {
    local depth="${1:-0}" ; local indent="" ; for ((i=0; i<depth; i++)) ; do indent+="  " ; done
    debug "${indent}Killing tracked pids: [${spawned_pids[*]}]..."
    local pid
    for pid in "${spawned_pids[@]}"; do
        debug "${indent}  Kill $pid"
        kill -- "$pid" 2>/dev/null || true
    done
}
spawned_pids=()

# cleanup is the main cleanup function called on exit.
#
# cleanup_all first because it is the most thorough, but requires pgrep.
# cleanup_tracked second as a fallback, it only requires kill.
#
# Usage: cleanup
function cleanup {
    debug "Cleaning up all child processes..."
    cleanup_all "$1" false 1 || true
    debug "Cleaning up tracked child processes..."
    cleanup_tracked 1 || true
    debug "Cleaned up child processes"
}

# Clean up child processes on exit
trap 'cleanup $$ false' EXIT INT TERM HUP


function dispatch {
    debug "Dispatch"
    local cmd="$1"
    case "$cmd" in
        dive|hist) shift || true ; dive "$@" ; return ;;
        surf|insp) shift || true ; surf "$@" ; return ;;
        help|-h|--help) shift || true ; help "$@" ; return ;;
    esac

    local nfiles=0
    local ext=""
    local record=false
    local arg=""

    for arg in "$@"; do
        case "$arg" in
            --record|--rec|-r) record=true ;;
            -*) ;;  # other options
            *.jsonl|*.ndjson) ext="jsonl" ; nfiles=$((nfiles + 1)) ;;
            *.json) ext="json" ; nfiles=$((nfiles + 1)) ;;
            *) nfiles=$((nfiles + 1)) ;;
        esac
    done

    local choice=""

    case "$ext" in
        jsonl|ndjson) choice=dive ;;
        json) if [[ "$record" = true || $nfiles -gt 1 ]] ; then choice=dive ; else choice=surf ; fi ;;
        *) choice=dive ;;
    esac

    debug "  nfiles: $nfiles"
    debug "  ext: $ext"
    debug "  record: $record"
    debug "  choice: $choice"

    "$choice" "$@"
}

dispatch "$@"
